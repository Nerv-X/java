package com.other;

import org.junit.Test;
/**
 * Java的数据表示顺序：大端排列，即左侧高位，右侧低位
 * Java的数值基本类型都是有符号类型，最高位0/1表示正数/负数。-n的二进制表示方法：n的补码加1
 * 带符号类型扩展：当小范围类型向大范围类型转换时，正数在高位补0，负数补1
 * ------------------------------------------------------------
 * 与
 * 		0 & 1 = 0	// 负数按补码形式运算
 * 	推论
 * 		· & 1，值不变
 * 		· 截取，与的结果是两个操作数的最小位数，因为低位值不变而高位全0
 * 		· 清零，&0一定是0
 * 	字节码指令
 * 		iand、land
 * ------------------------------------------------------------
 * 或
 * 		0 | 1 = 1	// 负数按补码形式运算
 * 	字节码指令：ior、lor
 * ------------------------------------------------------------
 * 异或
 * 		0 ^ 1 = 1	// 两个数相同则0，不同为1
 * 	推论
 * 		^ 1，值不变；^ 0，值一定变
 * 	字节码指令
 * 		ixor、lxor
 * ------------------------------------------------------------
 * 取反
 * 		~1 = 0
 * 	字节码指令
 * 		ineg、lneg、fneg、dneg
 * 	优先级
 * 		高于算术运算符、关系运算符、逻辑运算符和其他运算符
 * ------------------------------------------------------------
 * 移位
 * 		<< n	左移，高位舍弃，低位补0，相当于乘以 2的n次方
 * 		>> n	右移，低位舍弃，高位补符号位（正数0，负数1），相当于除以2的n次方
 * 		>>> n	无符号右移，低位舍弃，高位补0
 * 	字节码指令
 * 		ishl、ishr、iushr、lshr、lshr、lushr	（JVM只能处理int和long）
 * 	数据类型
 * 		int、byte、short和char类型：结果int，实际移动次数 = (n % 32)
 * 		long：结果long，实际移动次数 = (n % 64)
 * ------------------------------------------------------------
 * 复合赋值运算符
 * 		&=		例：a &= b		相当于a=a & b
 * 		|=		例：a |= b		相当于a=a | b
 * 		>>=		例：a >>= b		相当于a=a >> b
 * 		<<=		例：a <<= b		相当于a=a << b
 * 		^=		例：a ^= b		相当于a=a ^ b
 * ------------------------------------------------------------
 * 应用实例
 * 		Long.getChars(long, index, char[])		乘法和移位运算代替除法
 * 		Long.toUnsignedString(long, int shift)	移位运算实现进制转换
 * 
 * 参考资料
 * 	https://blog.csdn.net/weixin_34409822/article/details/90661394
 * 
 * @author nerv
 *
 */
public class 位运算 {

	private final int N = 0b11110001_11110011_11001001_00110011;
	
	/**
	 * 与运算：截断效果
	 */
	@Test
	public void test1() {
		// 32bit数与 0xff被截断，剩下最低8位（前24位都是0）
		int n =  N & 0xff;
		n = n & 0;
		System.out.println(Integer.toBinaryString(n));
	}
	
	/**
	 * 符号
	 * 	Java的数值基本类型都是有符号类型，最高位0/1表示正数/负数
	 * 	当小范围类型向大范围类型转换时，正数在高位补0，负数补1
	 */
	@Test
	public void test3() {
		byte b = (byte) 0b11001001;		// byte型负数
		int n = b;						// 负数类型转换时，高位补1
		// n == b == 0b11111111111111111111111111001001，是负数
		// (n & 0xff) == 0b11001001 == 0b000000000000000011001001，是正数
		System.out.println(Integer.toBinaryString(n));
		System.out.println((b & 0xff));
	}
	
	/**
	 * 移位运算，int与byte[]互转
	 */
	@Test
	public void test2() {
		// 1. int转byte[]
			// 数组的索引顺序是左低右高，数据表示顺序是左高右低
			// 此处用数组低索引元素存int低位字节
		byte[] b = {
				N & 0xff,
				(byte) (N >> 8 & 0xff),	// 转byte后最高位变符号位，1即负数（无符号数变成有符号数，值已改变）
				(byte) (N >>> 16 & 0xff),
				(byte) (N >> 24 & 0xff)
		};
		// 2. byte[]转int
			// byte还原时，负数要将有符号byte值转为无符号数
			// 因为位运算需要先将byte转int，负数在高位补1。& 0xff将第9~32位变为0，恢复原无符号值
		int N2 = (b[3]& 0xff) <<24 | (b[2]& 0xff)<<16 | (b[1] &0xff)<<8| (b[0]& 0xff);
		System.out.println(N2 == N);
	}
	
	
}
